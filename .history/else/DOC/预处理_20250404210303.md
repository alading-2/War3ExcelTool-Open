生成新的 python 文件：pretreatment.py，在 src\core

**1. 总结当前需求：**

-**目标：** 在 Excel 文件的前几行（指定为前 3 行）添加预处理指令。

-**作用范围：** 指令针对特定列。

-**存储：** 将提取的指令和值存入 `ColumnInfo` 类中。

-**提取方式：** 使用正则表达式从单元格内容中提取指令（如 `#default`、`#path`）和对应的值（如果存在）。

-**数据结构：** 考虑使用字典存储指令和值。

-**清理：** 提取后，需要移除包含预处理指令的行。

-**具体指令：**

    -`#default <value>`：为该列的空单元格（NaN）设置默认值 `<value>`。

    -`#path`：将该列的字符串值中的 `\` 替换为 `\\`（针对魔兽路径格式）。

**2. 优化与思考：**

-**指令存储：** 在 `ColumnInfo` 类中使用字典（例如 `preprocessing_rules: Dict[str, Any]`）来存储提取的 `指令: 值` 对，是灵活且可扩展的方式。对于没有值的指令（如 `#path`），可以将值设为 `True` 或 `None`。

-**指令解析：**

    - 正则表达式需要健壮，能处理指令前后的空格，以及指令有无值的情况。例如`^\s*(#\w+)\s*(.*)\s*$` 可以捕获指令（组1）和剩余的值部分（组2），后续再对值进行处理。

    - 指令集合最好定义成常量（如`VALID_PREPROCESSORS = {"#default", "#path"}`），便于校验。

-**指令应用逻辑：**

    -**顺序：** 预处理指令的应用顺序很重要。例如，`#default` 应该在检查到 NaN 时应用，而 `#path` 应该在确认值为字符串后应用。需要明确数据处理流程中应用这些规则的阶段。

    -**扩展性：** 可以定义一个预处理函数分发机制。例如，一个字典 `PREPROCESSOR_ACTIONS = {"#default": apply_default, "#path": apply_path}`，根据解析到的指令调用相应的处理函数。

-**行数限制：** “前 3 行”是否固定？如果指令分布在第 1 行和第 3 行，如何处理？更灵活的方式可能是扫描文件开头，直到遇到第一个非指令行（或真正的表头行），并将之前的所有指令行都解析。这样可以处理任意数量的指令行。

-**表头识别：** 移除指令行后，需要正确识别哪一行是真正的表头。可以假设指令行之后的第一行是表头，但这需要验证。

-**错误处理：**

    - 无效指令（如`#paht`）：应该报错还是忽略？建议明确报错，指出无效指令及其位置。

    - 指令缺少必要值（如`#default` 但没有值）：报错。

    - 值类型错误（如`#default abc`）：尝试转换类型，如果失败则报错。

    -`#path` 应用于非字符串列：应该在应用 `#path` 之前检查列类型或单元格值类型，如果类型不匹配则跳过或警告。

-**`#path` 的细节：** 确认 `\` 替换为 `\\` 是否满足需求。TypeScript 或目标环境可能需要 `\\\\`（即原始字符串中的 `\\` 被转义为 `\\\\`，在代码中表示为 `\`）。文档中写的是 `\` -> `\\`，但例子是 `\` -> `\\`。需要澄清最终代码中期望的格式。例子 `ReplaceableTextures\CommandButtons\BTNStormBolt.blp` 变成 `ReplaceableTextures\\CommandButtons\\BTNStormBolt.blp` 是将单个反斜杠替换为两个。但在某些语言的字符串字面量中，要表示一个反斜杠，可能需要写 `\\`。如果目标 TypeScript 代码需要 `\`，那么 Python 字符串应该是 `'\\'`。如果目标 TS 代码需要 `\\`，Python 字符串应该是 `'\\\\'`。目前看起来用户的需求是生成包含 `\\` 的字符串。

**3. 生成下一步提示词：**

1. **读取与解析：**

   - 修改 `pandas.read_excel` 相关逻辑，使其能够读取 Excel 文件的前 N 行（例如 N=5，允许一定灵活性），逐行检查单元格内容是否包含预处理指令（以 `#` 开头）。
   - 使用正则表达式解析每个指令单元格，提取指令名称（如 `#default`）和可选的值。指令名称应在一个预定义的有效指令集合中进行验证。
   - 记录下包含指令的行号，以便后续移除。

2. **存储指令：**

   - 修改 `ColumnInfo` 类（或其他相关的数据结构），添加一个字典 `preprocessing_rules` 用于存储解析到的 `指令: 值` 对。对于同一个列的多个指令（可能来自不同行），需要合并存储。
   - 处理指令值：根据指令类型对值进行必要的类型转换（例如 `#default` 的值可能需要转为数字或保留为字符串）。

3. **数据加载调整：**

   - 确定实际的表头行号（应为最后一个指令行之后的那一行）。
   - 在 `pandas.read_excel` 时，使用 `header` 参数指定正确的表头行号，并使用 `skiprows` 参数跳过所有指令行。

4. **应用指令：**

   - 在数据转换/处理的核心逻辑中（例如，从 DataFrame 转换为目标结构之前），遍历每一列的数据。
   - 检查该列对应的 `ColumnInfo` 是否包含 `preprocessing_rules`。
   - 根据规则应用预处理：

     - `#default`: 检查单元格值是否为 NaN (或 `pd.isna()`)，如果是，则替换为 `#default` 指定的值。
     - `#path`: 检查单元格值是否为字符串，如果是，则将其中的 `\` 替换为 `\\`。

   - 确保预处理的应用顺序合理（例如，先应用 `#default` 再进行类型特定的处理如 `#path`）。

5. **错误处理：**

   - 添加健壮的错误处理机制：

     - 报告无法识别的指令或格式错误的指令（如缺少值）。
     - 报告值类型转换失败的情况。
     - 提供清晰的错误信息，包含指令、值、列名和行号（原始 Excel 中的行号）。

6. **代码实现：**

   - 请提供具体的 Python 代码实现，包括对 `pandas` 使用的调整、正则表达式、`ColumnInfo` 的修改以及应用这些规则的数据处理逻辑。
   - 考虑使用函数分发或其他可扩展的方式来处理不同的指令，而不是大量的 `if/elif` 语句。
